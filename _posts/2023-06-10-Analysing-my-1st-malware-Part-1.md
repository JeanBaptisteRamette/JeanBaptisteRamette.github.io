---
title: "Part 1 of Analysing my first malware: Strings Deciphering"
layout: post
---


### Disclaimer

I am just a beginner in malware analysis, I'm writing this blogpost to help others and because
it's good practice:
> If I can't explain something correctly, then I do not really understand it.


If you want to follow along, you can download the sample on [MalwareBazaar](https://bazaar.abuse.ch/sample/4eb33ce768def8f7db79ef935aabf1c712f78974237e96889e1be3ced0d7e619/)

## Introduction

Hi ! Today I am going to start reverse engineering my first malware ! Let me introduce you to 
`Hamweq`, a malware categorized as an `IRC Botnet`. You can find more about our friend by 
looking up its SHA256 hash `4eb33ce768def8f7db79ef935aabf1c712f78974237e96889e1be3ced0d7e619`

Let's load the binary directly into IDA and get our hands dirty !

## First glance from IDA

The binary is a 32-bit windows executable, looking at the different IDA tables, we can see that it has very few functions, imports, and unobfuscated strings:

![IDA tables](/assets/blog-posts-part1/ss_tables.png)

We can immediatly guess that the malware will use dynamic API resolving with `LoadLibrary` & `GetProcAddress` after deciphering the names of the DLLs and their procedures !


## Main Function

The main function first calls the following subroutine, with lpName pointing to `"SeDebugPrivilege"`
```cpp
BOOL __cdecl sub_402781(LPCSTR lpName)
{
  HANDLE v1; // eax
  BOOL result; // eax
  BOOL v3; // esi
  struct _TOKEN_PRIVILEGES NewState; // [esp+0h] [ebp-14h] BYREF
  HANDLE TokenHandle; // [esp+10h] [ebp-4h] BYREF

  v1 = GetCurrentProcess();
  result = OpenProcessToken(v1, 0x28u, &TokenHandle);  // 0x28 = TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES
  if ( result )
  {
    v3 = 0;
    if ( LookupPrivilegeValueA(0, lpName, (PLUID)NewState.Privileges) )// SeDebugPrivilege
    {
      NewState.Privileges[0].Attributes |= 2u;
      NewState.PrivilegeCount = 1;
      v3 = AdjustTokenPrivileges(TokenHandle, 0, &NewState, 0, 0, 0);
    }
    CloseHandle(TokenHandle);
    result = v3;
  }
  return result;
}
```
This will try to adjust the SeDebug privilege with `SE_PRIVILEGE_ENABLED` (0x2u) , effectively trying to elevate privileges

After this function, `sub_4027E1` is called with the string `"I0L0v3Y0u0V1rUs"`, followed by a `LoadLibraryA` call:

![Call to LoadLibraryA](/assets/blog-posts-part1/loadlibrary.png)

The argument to `LoadLibraryA` being encrypted, we know that `sub_4027E1` has to decrypt some strings...

## Decryption routine
Looking at `sub_4027E1`, there is no doubt that it is in fact our decryption routine, and the string `"I0L0v3Y0u0V1rUs"` is our key

```cpp
void __cdecl sub_4027E1(LPCSTR lpString)
{
  LPCSTR *v1; // eax
  LPCSTR *v2; // esi
  int v3; // ebx
  int i; // ebp
  CHAR *v5; // eax

  if ( lpLibFileName )
  {
    v1 = &lpLibFileName;
    v2 = &lpLibFileName;
    do
    {
      v3 = 0;
      if ( lstrlenA(*v1) > 0 )
      {
        do
        {
          for ( i = 0; i < lstrlenA(lpString); ++i )
            (*v2)[v3] ^= lpString[i];
          v5 = (CHAR *)&(*v2)[v3++];
          *v5 = ~*v5;
        }
        while ( v3 < lstrlenA(*v2) );
      }
      v1 = ++v2;
    }
    while ( *v2 );
  }
}
```

`lpLibFileName` points to a table in the `.data` section containing the encrypted strings

The algorithm does the following:

1. For each encrypted string -> `while (*v2)`
2. For each character of the encrypted string -> `while ( v3 < lstrlenA(*v2))`
3. xor the character with each character of the decryption key `"I0L0v3Y0u0V1rUs"` -> `for ( i = 0; i < lstrlenA(lpString); ++i ) (*v2)[v3] ^= lpString[i];`
4. invert every bits from the character -> `*v5 = ~*v5;`
