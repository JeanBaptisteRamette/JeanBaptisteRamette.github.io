---
title: "Part 2 of Analysing my first malware: Process Injection"
layout: post
---


## Process Walking

In the last blog post, we were left with the following code

{:style="text-align:center;"}
![Process Walking Code](/assets/blog-posts-part2/process_search.png)

Here the local variable `v35` and `v36` could not be deduced properly by IDA as it could not resolve the APIs it was used with, but we now know that `v35` is of 
type `PROCESSENTRY32` because it is used with `Process32First/Process32Next`, let's retype it and we get an even cleaner view of what's happening.

{:style="text-align:center;"}
![Process Walking Code Retyped](/assets/blog-posts-part2/process_search_retyped.png)

The malware is doing process walking, iterating over each process and comparing names in order to find `explorer.exe` and get a handle to it.
The desired access flags `1082 = 0x43A = PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION | PROCESS_CREATE_THREAD` indicates
that the malware is certainly going to inject into this process.

{:style="text-align:center;"}
![Malware reusing variable](/assets/blog-posts-part2/reusing_variable.png)

We also note that the malware reuses variables a lot voluntarily, making it harder to see what's going on by just skimming over the code, so we have to rename variables as we analyse code everytime.


## Writing Data Remotely


{:style="text-align:center;"}
![Remote Process Writing](/assets/blog-posts-part2/remote_memory_write.png)

Next the malware allocates and writes data to the memory of the remote process. The written data looks like this, hence the `ptr_strings += 8`

{:style="text-align:center;"}
![Written data](/assets/blog-posts-part2/written_strings.png)

It does the same with some other weird empty strings, which do not make sense either at the moment

{:style="text-align:center;"}
![Written data](/assets/blog-posts-part2/written_strings2.png)

It then writes functions to the remote process.

{:style="text-align:center;"}
![Writing functions with VirtuallAlloc/WriteVirtualMemory](/assets/blog-posts-part2/remote_function_writing.png)

The `nullsub_1 - sub_XXXX` you see looks like a trick to make sure it copies each function entirely. The `nullsub_1` is just a dummy function located at the end of the `.text` section,
so the operation `nullsub_1 - sub_XXXX` result in the potentially maximum size of the function being copied.

The `v75` array is important because it contains the pointers to where the functions were allocated in the remote process.

{:style="text-align:center;"}
![Saving more functions to be exported](/assets/blog-posts-part2/saving_apis1.png)

Finally they save Windows API functions onto the stack. Then writes them to the remote process: `if ( !(ZwWriteVirtualMemory)(hRemoteProc, buffer, WinApiFunctions, 180, &BytesWritten) )`
Only the WinApiFunctions array seems written, but you can see they pass in a length of 180 bytes to be copied which is way bigger than our 32 bytes `WinApiFunctions` array

{:style="text-align:center;"}
![Look at the stack](/assets/blog-posts-part2/saving_apis2.png)

Now you see that all the functions are contiguous on the stack, we can merge it all into a big array of `180 / 4 = 45` entries to make more sense out of this.

{:style="text-align:center;"}
![Merging stack variables into one big array](/assets/blog-posts-part2/saving_apis3.png)


## Finalising Process Injection

The final thing the malware is doing is the following:

```cpp
// Allocate memory for savig WinApiFunctions array
buffer = (VirtualAllocEx)(hRemoteProc, 0, 180, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
WinApiFunctionsRemoteAddr = buffer;
if ( buffer )
{
    // Write the saved WinApiFunctions array
    if ( !(ZwWriteVirtualMemory)(hRemoteProc, buffer, WinApiFunctions, 180, &BytesWritten) )
    {
        FunctionsReferences[0] = WinApiFunctionsRemoteAddr;
        
        // Allocate memory for saving the malware defined functions array
        MalwareFunctionsRemoteAddr = (VirtualAllocEx)(hRemoteProc, 0, 16, MEM_COMMIT, 64);
        if ( MalwareFunctionsRemoteAddr )
        {
            // Write the array of pointers to the functions to be injected (notice this is v75 which I talked about earlier)
            if ( !(ZwWriteVirtualMemory)(hRemoteProc, MalwareFunctionsRemoteAddr, v75, 16, &BytesWritten) )
            {
                FunctionsReferences[1] = MalwareFunctionsRemoteAddr;

                // Allocate memory for saving all the functions passed to the remote process 
                FunctionsTable = (VirtualAllocEx)(hRemoteProc, 0, 968, MEM_COMMIT, 64);
                if ( FunctionsTable )
                {
                    // Write all the functions passed to the remote process 
                    if ( !(ZwWriteVirtualMemory)(hRemoteProc, FunctionsTable, FunctionsReferences, 968, &BytesWritten) )
                    {
                        CreateRemoteThread = GetProcAddress(hKernel32DLL, aCreateremoteth_0);

                        // Create a remote thread to the explorer.exe process
                        if ( (CreateRemoteThread)(hRemoteProc, 0, 0, StartRoutine, FunctionsTable, 0, v36) )
                        {
                            (WinApiFunctions[8])(hRemoteProc);
                            ExitProcess(0);
                        }
                    }
                }
            }
        }
    }
}
```

`if ( (CreateRemoteThread)(hRemoteProc, 0, 0, StartRoutine, FunctionsTable, 0, v36) )`
The `StartRoutine` argument will be the thread's entry point, and `FunctionsTable` the entry point's argument, `FunctionsTable` contains all the addresses of the injected functions written into `explorer.exe`.


## Conclusion

We analysed the techniques used by the malware to perform process injection. The malware uses the very well known and easy `VirtualAllocEx/ZwWriteVirtualMemory/CreateRemoteThread` combination.

1. `VirtualAllocEx` is responsible for allocating memory inside the remote process (where the malware will write its malicious code).
2. `ZwWriteVirtualMemory` will simply copy from the malware process to the remote process.
3. `CreateRemoteThread` creates a thread inside the remote process, executing the injected code.


Thanks for reading this post, see you in the next one :D
